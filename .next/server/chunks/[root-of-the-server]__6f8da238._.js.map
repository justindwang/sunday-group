{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file:///Users/justin/github2/sunday-group/app/api/room/data.ts"],"sourcesContent":["import { Participant, Group } from '../../utils/types';\n\n// In-memory storage for room data\n// In a production app, you would use a database\ninterface RoomData {\n  participants: Participant[];\n  groups: Group[] | null;\n  isGroupsFormed: boolean;\n}\n\n// Initialize with empty data\nconst roomsData: Record<string, RoomData> = {\n  'sunday-group': {\n    participants: [],\n    groups: null,\n    isGroupsFormed: false\n  }\n};\n\nexport function getRoomData(roomId: string): RoomData {\n  // Return the room data or create it if it doesn't exist\n  if (!roomsData[roomId]) {\n    roomsData[roomId] = {\n      participants: [],\n      groups: null,\n      isGroupsFormed: false\n    };\n  }\n  return roomsData[roomId];\n}\n\nexport function updateRoomData(roomId: string, data: Partial<RoomData>): RoomData {\n  const room = getRoomData(roomId);\n  \n  // Update only the provided fields\n  if (data.participants !== undefined) {\n    room.participants = data.participants;\n  }\n  \n  if (data.groups !== undefined) {\n    room.groups = data.groups;\n  }\n  \n  if (data.isGroupsFormed !== undefined) {\n    room.isGroupsFormed = data.isGroupsFormed;\n  }\n  \n  return room;\n}\n\nexport function resetRoom(roomId: string): void {\n  roomsData[roomId] = {\n    participants: [],\n    groups: null,\n    isGroupsFormed: false\n  };\n}\n"],"names":[],"mappings":";;;;;AAUA,6BAA6B;AAC7B,MAAM,YAAsC;IAC1C,gBAAgB;QACd,cAAc,EAAE;QAChB,QAAQ;QACR,gBAAgB;IAClB;AACF;AAEO,SAAS,YAAY,MAAc;IACxC,wDAAwD;IACxD,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE;QACtB,SAAS,CAAC,OAAO,GAAG;YAClB,cAAc,EAAE;YAChB,QAAQ;YACR,gBAAgB;QAClB;IACF;IACA,OAAO,SAAS,CAAC,OAAO;AAC1B;AAEO,SAAS,eAAe,MAAc,EAAE,IAAuB;IACpE,MAAM,OAAO,YAAY;IAEzB,kCAAkC;IAClC,IAAI,KAAK,YAAY,KAAK,WAAW;QACnC,KAAK,YAAY,GAAG,KAAK,YAAY;IACvC;IAEA,IAAI,KAAK,MAAM,KAAK,WAAW;QAC7B,KAAK,MAAM,GAAG,KAAK,MAAM;IAC3B;IAEA,IAAI,KAAK,cAAc,KAAK,WAAW;QACrC,KAAK,cAAc,GAAG,KAAK,cAAc;IAC3C;IAEA,OAAO;AACT;AAEO,SAAS,UAAU,MAAc;IACtC,SAAS,CAAC,OAAO,GAAG;QAClB,cAAc,EAAE;QAChB,QAAQ;QACR,gBAAgB;IAClB;AACF","debugId":null}},
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":["file:///Users/justin/github2/sunday-group/app/utils/groupFormation.ts"],"sourcesContent":["import { Participant, Group, generateUniqueId, getRandomBibleBook } from './types';\n\n/**\n * Forms groups from a list of participants\n * - Groups should have 4-6 people\n * - Each group must have at least one willing leader\n * - Returns null if not enough leaders are available\n */\nexport function formGroups(participants: Participant[]): Group[] | null {\n  if (participants.length === 0) return [];\n  \n  // Count willing leaders\n  const willingLeaders = participants.filter(p => p.isWillingToLead);\n  \n  // Calculate how many groups we need\n  const minGroupSize = 4;\n  const maxGroupSize = 6;\n  const totalParticipants = participants.length;\n  \n  // Calculate min and max number of groups possible\n  const maxGroups = Math.floor(totalParticipants / minGroupSize);\n  const minGroups = Math.ceil(totalParticipants / maxGroupSize);\n  \n  // If we don't have enough leaders, return null\n  if (willingLeaders.length < minGroups) {\n    return null;\n  }\n  \n  // Determine optimal number of groups\n  let numGroups = Math.min(maxGroups, willingLeaders.length);\n  numGroups = Math.max(numGroups, minGroups);\n  \n  // Shuffle participants\n  const shuffledParticipants = [...participants].sort(() => Math.random() - 0.5);\n  \n  // Separate leaders and non-leaders\n  const leaders = shuffledParticipants.filter(p => p.isWillingToLead);\n  const nonLeaders = shuffledParticipants.filter(p => !p.isWillingToLead);\n  \n  // Initialize groups with one leader each\n  const groups: Group[] = [];\n  for (let i = 0; i < numGroups; i++) {\n    if (i < leaders.length) {\n      groups.push({\n        id: `group-${i + 1}`,\n        name: `Group ${i + 1}`,\n        participants: [leaders[i]],\n        hasLeader: true\n      });\n    }\n  }\n  \n  // Distribute remaining leaders\n  for (let i = numGroups; i < leaders.length; i++) {\n    const groupIndex = i % numGroups;\n    groups[groupIndex].participants.push(leaders[i]);\n  }\n  \n  // Distribute non-leaders evenly\n  for (let i = 0; i < nonLeaders.length; i++) {\n    // Find the group with the fewest participants\n    const groupIndex = groups\n      .map((group, index) => ({ index, count: group.participants.length }))\n      .sort((a, b) => a.count - b.count)[0].index;\n    \n    groups[groupIndex].participants.push(nonLeaders[i]);\n  }\n  \n  // Update participant groupIds\n  groups.forEach(group => {\n    group.participants.forEach(participant => {\n      participant.groupId = group.id;\n    });\n  });\n  \n  return groups;\n}\n"],"names":[],"mappings":";;;AAQO,SAAS,WAAW,YAA2B;IACpD,IAAI,aAAa,MAAM,KAAK,GAAG,OAAO,EAAE;IAExC,wBAAwB;IACxB,MAAM,iBAAiB,aAAa,MAAM,CAAC,CAAA,IAAK,EAAE,eAAe;IAEjE,oCAAoC;IACpC,MAAM,eAAe;IACrB,MAAM,eAAe;IACrB,MAAM,oBAAoB,aAAa,MAAM;IAE7C,kDAAkD;IAClD,MAAM,YAAY,KAAK,KAAK,CAAC,oBAAoB;IACjD,MAAM,YAAY,KAAK,IAAI,CAAC,oBAAoB;IAEhD,+CAA+C;IAC/C,IAAI,eAAe,MAAM,GAAG,WAAW;QACrC,OAAO;IACT;IAEA,qCAAqC;IACrC,IAAI,YAAY,KAAK,GAAG,CAAC,WAAW,eAAe,MAAM;IACzD,YAAY,KAAK,GAAG,CAAC,WAAW;IAEhC,uBAAuB;IACvB,MAAM,uBAAuB;WAAI;KAAa,CAAC,IAAI,CAAC,IAAM,KAAK,MAAM,KAAK;IAE1E,mCAAmC;IACnC,MAAM,UAAU,qBAAqB,MAAM,CAAC,CAAA,IAAK,EAAE,eAAe;IAClE,MAAM,aAAa,qBAAqB,MAAM,CAAC,CAAA,IAAK,CAAC,EAAE,eAAe;IAEtE,yCAAyC;IACzC,MAAM,SAAkB,EAAE;IAC1B,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,IAAK;QAClC,IAAI,IAAI,QAAQ,MAAM,EAAE;YACtB,OAAO,IAAI,CAAC;gBACV,IAAI,CAAC,MAAM,EAAE,IAAI,GAAG;gBACpB,MAAM,CAAC,MAAM,EAAE,IAAI,GAAG;gBACtB,cAAc;oBAAC,OAAO,CAAC,EAAE;iBAAC;gBAC1B,WAAW;YACb;QACF;IACF;IAEA,+BAA+B;IAC/B,IAAK,IAAI,IAAI,WAAW,IAAI,QAAQ,MAAM,EAAE,IAAK;QAC/C,MAAM,aAAa,IAAI;QACvB,MAAM,CAAC,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;IACjD;IAEA,gCAAgC;IAChC,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,IAAK;QAC1C,8CAA8C;QAC9C,MAAM,aAAa,OAChB,GAAG,CAAC,CAAC,OAAO,QAAU,CAAC;gBAAE;gBAAO,OAAO,MAAM,YAAY,CAAC,MAAM;YAAC,CAAC,GAClE,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,KAAK,GAAG,EAAE,KAAK,CAAC,CAAC,EAAE,CAAC,KAAK;QAE7C,MAAM,CAAC,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;IACpD;IAEA,8BAA8B;IAC9B,OAAO,OAAO,CAAC,CAAA;QACb,MAAM,YAAY,CAAC,OAAO,CAAC,CAAA;YACzB,YAAY,OAAO,GAAG,MAAM,EAAE;QAChC;IACF;IAEA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 181, "column": 0}, "map": {"version":3,"sources":["file:///Users/justin/github2/sunday-group/app/api/room/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getRoomData, updateRoomData, resetRoom } from './data';\nimport { Participant, Group } from '../../utils/types';\nimport { formGroups } from '../../utils/groupFormation';\n\n// Configure the API route to be dynamic\nexport const dynamic = 'force-dynamic';\n\n// GET /api/room?roomId=sunday-group\nexport async function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams;\n  const roomId = searchParams.get('roomId') || 'sunday-group';\n  \n  const roomData = getRoomData(roomId);\n  \n  return NextResponse.json(roomData);\n}\n\n// POST /api/room\n// Actions: addParticipant, removeParticipant, formGroups, resetGroups, resetRoom\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { roomId = 'sunday-group', action, data } = body;\n    \n    const roomData = getRoomData(roomId);\n    \n    switch (action) {\n      case 'addParticipant': {\n        const { name, isWillingToLead } = data;\n        const newParticipant: Participant = {\n          id: data.id || Math.random().toString(36).substring(2, 9),\n          name,\n          isWillingToLead\n        };\n        \n        const updatedParticipants = [...roomData.participants, newParticipant];\n        updateRoomData(roomId, { participants: updatedParticipants });\n        \n        return NextResponse.json({ \n          success: true, \n          participant: newParticipant,\n          participants: updatedParticipants\n        });\n      }\n      \n      case 'removeParticipant': {\n        const { participantId } = data;\n        const updatedParticipants = roomData.participants.filter(\n          p => p.id !== participantId\n        );\n        \n        updateRoomData(roomId, { participants: updatedParticipants });\n        \n        return NextResponse.json({ \n          success: true,\n          participants: updatedParticipants\n        });\n      }\n      \n      case 'formGroups': {\n        const newGroups = formGroups(roomData.participants);\n        \n        if (newGroups === null) {\n          return NextResponse.json({ \n            success: false,\n            error: 'Not enough willing leaders to form groups'\n          });\n        }\n        \n        // Update participants with their group assignments\n        const updatedParticipants = roomData.participants.map(p => {\n          const group = newGroups.find(g => \n            g.participants.some(gp => gp.id === p.id)\n          );\n          \n          if (group) {\n            return { ...p, groupId: group.id };\n          }\n          \n          return p;\n        });\n        \n        updateRoomData(roomId, { \n          groups: newGroups,\n          participants: updatedParticipants,\n          isGroupsFormed: true\n        });\n        \n        return NextResponse.json({ \n          success: true,\n          groups: newGroups,\n          participants: updatedParticipants,\n          isGroupsFormed: true\n        });\n      }\n      \n      case 'resetGroups': {\n        // Clear group assignments from participants\n        const updatedParticipants = roomData.participants.map(p => ({\n          ...p,\n          groupId: undefined\n        }));\n        \n        updateRoomData(roomId, {\n          groups: null,\n          participants: updatedParticipants,\n          isGroupsFormed: false\n        });\n        \n        return NextResponse.json({ \n          success: true,\n          groups: null,\n          participants: updatedParticipants,\n          isGroupsFormed: false\n        });\n      }\n      \n      case 'resetRoom': {\n        resetRoom(roomId);\n        \n        return NextResponse.json({ \n          success: true,\n          participants: [],\n          groups: null,\n          isGroupsFormed: false\n        });\n      }\n      \n      default:\n        return NextResponse.json(\n          { success: false, error: 'Invalid action' },\n          { status: 400 }\n        );\n    }\n  } catch (error) {\n    console.error('API error:', error);\n    return NextResponse.json(\n      { success: false, error: 'Server error' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}